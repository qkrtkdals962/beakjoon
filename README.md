# 백준 단계별 문제 풀이 기록 (25년 7월 19일 시작)
## Dev C++를 사용하여 C언어로 문제를 품

## 📚 목차
- [1단계: 입출력과 사칙연산](#1단계-입출력과-사칙연산)
- [2단계: 조건문](#2단계-조건문)
- [3단계: 반복문](#3단계-반복문)
- [4단계: 1차원 배열](#4단계-1차원-배열)
- [5단계: 문자열](#5단계-문자열)
- [6단계: 심화1](#6단계-심화1)
- [7단계: 수학1](#7단계-수학1)
- [8단계: 약수, 배수와 소수1](#8단계-약수-배수와-소수1)
- [9단계: 기하1 직사각형과 삼각형](#9단계-기하1-직사각형과-삼각형)

---

## 1단계: 입출력과 사칙연산
- [10171 - 고양이](https://www.acmicpc.net/problem/10171)  
  ⚠️ 백슬래시 `\\`와 줄바꿈 `\n` 주의
  
- [10172 - 개](https://www.acmicpc.net/problem/10172)  
  ⚠️ 쌍따옴표 `"`, 공백, `\\` 출력 정확히
  
- [10926 - ??!](https://www.acmicpc.net/problem/10926)  
  ⚠️ 주의할 점: 단순 문자열 출력, 개행 포함 잊지 말기
  
- [1008 - A/B](https://www.acmicpc.net/problem/1008)
  ⚠️ 실수 나눗셈: `(double)A / B`로 계산해야 함  
  ⚠️ 출력 시 `printf("%.10g\n", 결과);`로 불필요한 0 생략
  
---

## 2단계: 조건문
- [조건식 - 100의 배수가 아님](https://www.acmicpc.net/problem/2753)  
  ⚠️ `a % 100 != 0` 으로 표현해야 함. `a % 100 /= 0`은 잘못된 문법
  
- [2525 - 오븐 시계](https://www.acmicpc.net/problem/2525)  
  ⚠️ 시간 계산은 `(총분 / 60) % 24`, `총분 % 60` 방식이 간결하고 정확함  
  ⚠️ `a=23` 같은 대입문 실수 주의 → `a == 23` 비교 연산자 써야 함
  
- [2480 - 주사위 세 개](https://www.acmicpc.net/problem/2480)  
  ⚠️ `a == b == c`는 논리적으로 잘못됨 → `a == b && b == c`로 비교해야 함
  
---

## 3단계: 반복문
- [2438 - 별 찍기 - 1](https://www.acmicpc.net/problem/2438)  
  ⚠️ 줄 수 `N`만큼 반복하며, i번째 줄에 별 `*`을 i개 출력  
  ⚠️ 줄바꿈 `\n` 주의, 공백 없이 별만 출력  
  ✔️ 이중 반복문 (줄 수 + 별 개수)
  
- [2439 - 별 찍기 - 2](https://www.acmicpc.net/problem/2439)  
  ⚠️ 오른쪽 정렬된 별 출력 → 공백 먼저 출력 후 별 `*` 출력  
  ⚠️ 줄바꿈 `\n` 주의, 공백 개수는 `N - i`  
  ✔️ 이중 반복문 (공백 + 별 개수)
  
- [10951 - A+B - 4](https://www.acmicpc.net/problem/10951)  
  ⚠️ 입력 개수 없음 → EOF(End Of File)까지 계속 입력받기  
  ⚠️ C에서는 `while(scanf(...) != EOF)` 형태 사용  
  ✔️ 줄마다 두 수를 입력받고 합을 출력하는 반복문 구성
  
---

## 4단계: 1차원 배열
- [10810 - 공 넣기](https://www.acmicpc.net/problem/10810)  
  ⚠️ 배열 초기화: `int a[101] = {0};`  
  ⚠️ i~j 범위에 k값을 대입, 출력은 `1~n`번 바구니까지  

- [10813 - 공 바꾸기](https://www.acmicpc.net/problem/10813)  
  ⚠️ 값 교환 시 `swap` 사용  
  ⚠️ 배열 인덱스는 0부터 시작하지만 바구니 번호는 1부터 → 보정 필요  

- [10811 - 바구니 뒤집기](https://www.acmicpc.net/problem/10811)  
  ⚠️ 구간 i~j를 반으로 나눠 `swap`으로 역순 처리  
  ⚠️ 입력은 1부터 시작하므로 `i--, j--` 인덱스 보정 필수  

- [5597 - 과제 안 내신 분..?](https://www.acmicpc.net/problem/5597)  
  ⚠️ 체크 배열 사용: `int a[31] = {0};`  
  ⚠️ 입력 받은 번호만 `1`로 체크 후 `a[i] == 0`인 번호 출력  

- [3052 - 나머지](https://www.acmicpc.net/problem/3052)  
  ⚠️ 서로 다른 나머지 개수 체크  
  ⚠️ 방법 1: `int mod[42] = {0};` 배열로 체크  
  ⚠️ 방법 2: 앞에서 등장한 값인지 중첩 for문으로 중복 제거  

- [1546 - 평균](https://www.acmicpc.net/problem/1546)  
  ⚠️ 최댓값 기준으로 점수 조정: `(double)a[i]/m*100`  
  ⚠️ 출력 시 `printf("%g\n", total/n);` 사용해 불필요한 소수 생략

---

## 5단계: 문자열

### 📌 getchar / putchar vs scanf / printf

#### ✅ getchar / putchar
- **특징**
  - 문자 하나씩만 입출력하는 단순한 함수들.
  - `getchar()`는 표준 입력에서 한 글자를 읽어 `int`로 반환한다. (EOF 처리 가능)
  - `putchar()`는 문자 하나를 화면에 출력한다.
  - 공백과 개행도 그대로 처리할 수 있어, EOF까지 입력을 그대로 출력하는 문제에 적합하다.
- **장점**
  - 구현이 간단하고 빠르다.
  - EOF 처리를 쉽게 할 수 있다.
  - 한 글자 단위 제어가 필요한 문제에서 유리하다.
- **단점**
  - 문자 하나씩만 다루므로 숫자나 여러 변수의 포맷팅 입력에는 적합하지 않다.

#### ✅ scanf / printf
- **특징**
  - 다양한 타입의 데이터를 포맷에 맞춰 입출력하는 함수들.
  - `scanf()`는 `%d`, `%f`, `%s`, `%c` 등 서식 지정자를 사용해 여러 형태의 입력을 받을 수 있다.
  - `printf()`는 포맷 지정자를 사용해 숫자, 문자, 문자열을 원하는 형태로 출력할 수 있다.
- **장점**
  - 정수, 실수, 문자열 등 다양한 데이터 처리 가능.
  - 서식을 지정해 깔끔한 출력 제공.
- **단점**
  - `scanf()`는 공백을 기준으로 입력을 끊기 때문에 공백 포함 문자열 입력에는 적합하지 않다.
  - EOF 처리를 직접 확인하려면 추가 코드가 필요하다.

---

### 📌 비교 요약
| 구분            | getchar / putchar           | scanf / printf               |
|-----------------|-----------------------------|------------------------------|
| 입력 단위       | 문자 1개                    | 다양한 타입 (정수, 실수, 문자열 등) |
| 출력 단위       | 문자 1개                    | 다양한 타입, 포맷 지정 가능        |
| 공백/개행 처리   | 그대로 읽고 그대로 출력 가능 | 공백에서 입력 끊김 (`%s` 기준)    |
| EOF 처리        | 간단 (`getchar() != EOF`)   | 직접 검사 필요 (`scanf()` 반환값) |
| 사용 용도       | 한 글자씩 읽기, EOF 문제     | 숫자 입력, 포맷 출력, 여러 변수 처리 |

---

### 📌 아스키코드 변환
- `getchar()`로 읽은 문자는 아스키코드 값으로 `int`에 저장된다.
- `printf("%d", ch);` → 문자 → 아스키코드 값 출력.
- `putchar(ch);` 또는 `printf("%c", code);` → 아스키코드 값 → 문자 출력.
- `'0'`을 빼서 문자 숫자를 정수로 변환: `'7' - '0'` → 7
  
---

- [9086 - 문자열](https://www.acmicpc.net/problem/9086)  
  ⚠️ 문자열의 첫 번째, 마지막 문자 출력  
  ⚠️ `char str[101];` 입력 후 `str[0]`과 `str[strlen(str)-1]` 사용

- [10809 - 알파벳 찾기](https://www.acmicpc.net/problem/10809)  
  ⚠️ `int pos[26] = {-1};` 초기화 후 각 알파벳 첫 등장 위치 저장  
  ⚠️ `str[i] - 'a'`로 인덱스 계산

- [2675 - 문자열 반복](https://www.acmicpc.net/problem/2675)  
  ⚠️ 각 문자마다 R번 반복 출력  
  ⚠️ 중첩 for문: `for(j) for(k)` 구조, 출력은 `s[j]`

- [1152 - 단어의 개수](https://www.acmicpc.net/problem/1152)  
  ⚠️ 공백 → 글자 변환 시 단어 카운트  
  ⚠️ 문자열 시작/끝 공백 처리 주의, `fgets()` 또는 `getchar()` 사용 가능

- [11720 - 숫자의 합](https://www.acmicpc.net/problem/11720)  
  ⚠️ `char`로 입력받고 `'0'` 빼서 정수 변환  
  ⚠️ `for`문으로 각 자리 더하기

- [2908 - 상수](https://www.acmicpc.net/problem/2908)  
  ⚠️ 숫자를 문자열로 받아 자리수 뒤집기  
  ⚠️ `(a[2]-'0')*100 + (a[1]-'0')*10 + (a[0]-'0')` 계산

- [11718 - 그대로 출력하기](https://www.acmicpc.net/problem/11718)  
  ⚠️ EOF까지 입력을 그대로 출력  
  ⚠️ `while((ch=getchar()) != EOF) putchar(ch);`

---

## 6단계: 심화1

## 📌 strcmp() 함수 정리

- 문자열 두 개를 비교하는 함수 (C언어 표준 라이브러리 `<string.h>` 사용)
- 반환값으로 두 문자열의 사전순 관계를 알려줌

### 🔹 반환값 의미

- strcmp(a, b) == 0 → 문자열 a와 b가 같다
- strcmp(a, b) < 0 → 문자열 a가 b보다 사전순으로 앞
- strcmp(a, b) > 0 → 문자열 a가 b보다 사전순으로 뒤

### 🔹 주의할 점

- 문자열 비교에는 `==` 사용 ❌  
  (포인터 비교가 됨 → 올바르지 않음)
- 반드시 `strcmp()`를 사용해야 문자열 내용을 정확히 비교할 수 있음

---

- [10988 - 팰린드롬인지 확인하기](https://www.acmicpc.net/problem/10988)  
  ⚠️ 문자열 뒤집은 후 `strcmp(a, b)`로 비교  
  ⚠️ `strcmp(a, b) == 0` → 문자열 같음  
  ⚠️ `strcmp(a, b) < 0` → a가 사전순 앞  
  ⚠️ `strcmp(a, b) > 0` → a가 사전순 뒤  
  ⚠️ 문자열 뒤집기 후 마지막에 `b[length] = '\0';` 꼭 추가!

- [1157 - 단어 공부](https://www.acmicpc.net/problem/1157)  
  ⚠️ 대소문자 통일: `if(c >= 'a' && c <= 'z') c -= 32;`  
  ⚠️ 알파벳 등장 횟수: `int count[26]`  
  ⚠️ 최댓값 먼저 찾고, 동률이 몇 개인지 다시 탐색  
  ⚠️ 동률 ≥ 2 → `?` 출력, 아니면 알파벳 출력  

- [2941 - 크로아티아 알파벳](https://www.acmicpc.net/problem/2941)  
  ⚠️ 조합 발견 시 `i += 조합 길이 - 1`로 건너뛰기  
  ⚠️ 예: `dz=` → `i += 2`, `c=`, `lj` 등 → `i++`  
  ⚠️ 조합 여부와 관계없이 `count++`는 항상 실행  

- [1316 - 그룹 단어 체커](https://www.acmicpc.net/problem/1316)  
  ⚠️ 같은 문자가 연속해서 나오는 건 OK  
  ⚠️ 한 번 끝났던 문자가 다시 나오면 NG  
  ⚠️ 이전 문자 기억용 `prev`, 등장 기록용 `int alpha[26]` 사용
  
- [25206 - 너의 평점은](https://www.acmicpc.net/problem/25206)  
  ⚠️ 학점 × 평점 총합 / 학점 총합 (단, `P` 제외)  
  ⚠️ 문자열 비교: `strcmp(grade, "A+") == 0`  
  ⚠️ `break`는 반복문 종료 / `continue`는 이번 반복만 건너뜀

---

## 7단계: 수학1

- [2745 - 진법 변환](https://www.acmicpc.net/problem/2745)  
  ⚠️ B진수 → 10진수 변환  
  ⚠️ 입력 `N`은 문자열(`char N[31]`)로 받기 (A\~Z 포함)  
  ⚠️ 문자 → 숫자 변환: '0'\~'9' → c - '0', 'A'\~'Z' → c - 'A' + 10  
  ⚠️ 변환 방식 ① 왼쪽→오른쪽: num = num * B + digit;  
  ⚠️ 변환 방식 ② 오른쪽→왼쪽: num += digit * place; place *= B;  
  ⚠️ 출력은 long long → %lld 사용  

- [11005 - 진법 변환 2](https://www.acmicpc.net/problem/11005)
  ⚠️ 10진수 → B진수 변환  
  ⚠️ 알고리즘: while (N > 0) { r = N % B; ...; N /= B; }  
  ⚠️ 나머지 → 문자 변환: r < 10 → '0' + r, r >= 10 → 'A' + (r - 10)  
  ⚠️ 저장한 결과는 역순 출력 (스택 또는 배열 뒤집기)  
  ⚠️ N=0이면 특별히 "0" 출력 필요  
  ⚠️ 출력 루프는 printf("%c", num[i]); (인덱스 주의)

- [2720 - 세탁소 사장 동혁](https://www.acmicpc.net/problem/2720)
 ⚠️ 입력 금액은 센트 단위 정수로 처리(실수 0.25, 0.1 등 금지)
 ⚠️ 각 케이스마다 q, d, n, p 0으로 초기화
 ⚠️ 모든 단위 적용 → if 연속 사용, else if 금지
 ⚠️ 계산 흐름: q=C/25; C%=25; d=C/10; C%=10; n=C/5; C%=5; p=C;
 ⚠️ 출력 형식: "%d %d %d %d\n" (개행 포함)
 ⚠️ 미국 동전(25,10,5,1)은 그리디가 항상 최적

- [2292 - 벌집](https://www.acmicpc.net/problem/2292)
 ⚠️ 겹(레이어) 끝값 수열: 1, 7, 19, 37, 61, … (증가량 6, 12, 18, …)
 ⚠️ 누적 아이디어: end=1, layer=1에서 시작, while (N > end) { end += 6*layer; layer++; }
 ⚠️ N == 1이면 바로 1 (오프바이원 방지 위해 while (N > end))
 ⚠️ 일반식: k겹 끝값 = 1 + 3k(k-1)
 ⚠️ 개념상 거리 = layer - 1, 문제 출력은 겹 수(layer)

- [2869 - 달팽이는 올라가고 싶다](https://www.acmicpc.net/problem/2869)
 ⚠️ 하루 순이득 = A - B
 ⚠️ 마지막 날은 미끄러지지 않음 → V - A 기준으로 계산
 ⚠️ 올림(ceil) 필요: (x + y - 1) / y 형태로 구현
 ⚠️ 답 = ((V - A) + (A - B) - 1) / (A - B) + 1

---

## 8단계: 약수, 배수와 소수1

- [5086 - 배수와 약수](https://www.acmicpc.net/problem/5086)  
  ⚠️ 입력 `(a, b)`가 `0 0`이면 종료  
  ⚠️ `b % a == 0` → factor / `a % b == 0` → multiple / 나머지 → neither  
  ⚠️ while문 안에서 종료 조건을 먼저 확인해야 함  

- [1978 - 소수 찾기](https://www.acmicpc.net/problem/1978)  
  ⚠️ `n`개의 자연수 입력 후 소수 개수 출력  
  ⚠️ 소수 판별: `i < 2` → 소수 아님 / `2~√i`까지 나눠서 나누어 떨어지면 합성수  
  ⚠️ 소수일 때만 count++  

- [2581 - 소수](https://www.acmicpc.net/problem/2581)  
  ⚠️ 구간 `[M, N]`에서 소수의 합과 최소 소수 출력  
  ⚠️ 소수가 없으면 -1 출력  
  ⚠️ 합계 `total`과 최소값 `minPrime`만 추적하면 배열이 필요 없음  
  ⚠️ 배열을 쓴다면 크기는 반드시 `N - M + 1` 이상이어야 안전  

- [2501 - 약수 구하기](https://www.acmicpc.net/problem/2501)  
  ⚠️ 약수를 오름차순으로 세며 K번째를 찾기  
  ⚠️ 배열 사용 시 인덱스 주의: a[K-1] (배열은 0부터 시작)  
  ⚠️ 저장 없이도 가능: 약수 발견마다 count++, count==K 시 즉시 출력·종료, 끝까지 못 찾으면 0  

- [9506 - 약수들의 합](https://www.acmicpc.net/problem/9506)  
  ⚠️ -1이 입력되면 종료  
  ⚠️ 자기 자신을 제외한 약수 합이 n과 같으면 완전수  
  ⚠️ 출력 형식: n = a1 + a2 + ... (마지막만 개행)  
  ⚠️ 성능 팁: 1 ~ ⌊√n⌋까지만 순회하며 약수 쌍을 더하기 (단, i*i == n은 한 번만 더하기)  
  ⚠️ int 배열은 문자열이 아니므로 '\0' 처리 불필요 (필요 시 배열 없이 두 번 순회하는 방식이 깔끔)  

---

## 9단계: 기하1 직사각형과 삼각형

---

### C 삼항 연산자(조건 연산자) 요약

#### 개념
- 형태: `조건 ? 값1 : 값2`
- 의미: **조건이 참이면 값1**, 거짓이면 **값2**를 평가해 그 결과를 반환.
- 평가: `조건`은 한 번 평가되고, **값1/값2 중 딱 하나만** 평가됨(짧은 계산, if-else와 동일한 단락 평가).

---

- [1085 - 직사각형에서 탈출](https://www.acmicpc.net/problem/1085)  
  ⚠️ 후보 거리 4개: x, y, w - x, h - y 중 **최솟값** 출력  
  ⚠️ 변/꼭짓점에 있어도 분기 불필요(최솟값이 자동으로 0)  
  ⚠️ 오른쪽·위 거리 계산은 전체 − 현재 순서 유지  

- [3009 - 네 번째 점](https://www.acmicpc.net/problem/3009)  
  ⚠️ 축평행 직사각형 → 각 좌표(x, y)는 두 개가 같고 하나만 다름 → 한 번만 나온 x, y가 정답  
  ⚠️ 방법① 비교식: x = (x1==x2? x3 : (x1==x3? x2 : x1)), y도 동일  
  ⚠️ 방법② XOR: x = x1 ^ x2 ^ x3, y = y1 ^ y2 ^ y3  
  ⚠️ 정렬/입력 순서 무관  

- [9063 - 대지](https://www.acmicpc.net/problem/9063)  
  ⚠️ 모든 점을 포함하는 축평행 최소 직사각형의 면적  
  ⚠️ minX, maxX, minY, maxY 갱신 → (maxX - minX) * (maxY - minY)  
  ⚠️ 점이 1개면 면적 0  
  ⚠️ 초기화는 첫 점으로(또는 INT_MAX/INT_MIN), abs 쓰지 않기  

- [10101 - 삼각형 외우기](https://www.acmicpc.net/problem/10101)  
  ⚠️ a+b+c != 180 → Error  
  ⚠️ Equilateral : a==60 && b==60 && c==60 (또는 세 각 모두 같고 60)  
  ⚠️ Isosceles : (a==b) || (b==c) || (a==c)  
  ⚠️ Scalene : (a!=b) && (b!=c) && (a!=c)  
  ⚠️ 체인 비교 금지: a==b==c==60, a!=b!=c (의도대로 동작 안 함)  

- [5073 - 삼각형과 세 변](https://www.acmicpc.net/problem/5073)  
  ⚠️ 입력 0 0 0에서 종료  
  ⚠️ Invalid : 가장 긴 변 L, 나머지 합 S에 대해 S ≤ L (즉 a+b+c ≤ 2*L)  
  ⚠️ Equilateral / Isosceles / Scalene 판별은 10101과 동일  
  ⚠️ 정렬 불필요, 최댓값만 잡으면 됨

---
